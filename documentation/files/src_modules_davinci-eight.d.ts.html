<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/modules/davinci-eight.d.ts - davinci-eight</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../../assets/logo.png" title="davinci-eight"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 2.63.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/AmbientLight.html">AmbientLight</a></li>
                                <li><a href="../classes/ArrowBuilder.html">ArrowBuilder</a></li>
                                <li><a href="../classes/ArrowOptions.html">ArrowOptions</a></li>
                                <li><a href="../classes/AttribDataInfos.html">AttribDataInfos</a></li>
                                <li><a href="../classes/AttribMetaInfo
                TODO: AttribPointerInfo?.html">AttribMetaInfo
                TODO: AttribPointerInfo?</a></li>
                                <li><a href="../classes/AttribMetaInfos.html">AttribMetaInfos</a></li>
                                <li><a href="../classes/AttribProvider.html">AttribProvider</a></li>
                                <li><a href="../classes/BarnGeometry.html">BarnGeometry</a></li>
                                <li><a href="../classes/BoxBuilder.html">BoxBuilder</a></li>
                                <li><a href="../classes/BoxMesh.html">BoxMesh</a></li>
                                <li><a href="../classes/Cartesian1.html">Cartesian1</a></li>
                                <li><a href="../classes/Cartesian2.html">Cartesian2</a></li>
                                <li><a href="../classes/Cartesian3.html">Cartesian3</a></li>
                                <li><a href="../classes/Color.html">Color</a></li>
                                <li><a href="../classes/Color
                WARNING: In many object-oriented designs, types representing values are completely immutable.
                In a graphics library where data changes rapidly and garbage collection might become an issue,
                it is common to use reference types, such as in this design. This mutability can lead to
                difficult bugs because it is hard to reason about where a color may have changed..html">Color
                WARNING: In many object-oriented designs, types representing values are completely immutable.
                In a graphics library where data changes rapidly and garbage collection might become an issue,
                it is common to use reference types, such as in this design. This mutability can lead to
                difficult bugs because it is hard to reason about where a color may have changed.</a></li>
                                <li><a href="../classes/CuboidMesh.html">CuboidMesh</a></li>
                                <li><a href="../classes/CylinderArgs.html">CylinderArgs</a></li>
                                <li><a href="../classes/DefaultUniformProvider.html">DefaultUniformProvider</a></li>
                                <li><a href="../classes/DirectionalLight.html">DirectionalLight</a></li>
                                <li><a href="../classes/Drawable.html">Drawable</a></li>
                                <li><a href="../classes/DrawMode.html">DrawMode</a></li>
                                <li><a href="../classes/ElementArray.html">ElementArray</a></li>
                                <li><a href="../classes/ElementBuffer.html">ElementBuffer</a></li>
                                <li><a href="../classes/EllipsoidMesh.html">EllipsoidMesh</a></li>
                                <li><a href="../classes/Face3.html">Face3</a></li>
                                <li><a href="../classes/frustum.html">frustum</a></li>
                                <li><a href="../classes/Frustum.html">Frustum</a></li>
                                <li><a href="../classes/Geometry.html">Geometry</a></li>
                                <li><a href="../classes/GeometryAdapter.html">GeometryAdapter</a></li>
                                <li><a href="../classes/KleinBottleGeometry.html">KleinBottleGeometry</a></li>
                                <li><a href="../classes/Line3.html">Line3</a></li>
                                <li><a href="../classes/LocalModel.html">LocalModel</a></li>
                                <li><a href="../classes/Matrix4.html">Matrix4</a></li>
                                <li><a href="../classes/Model.html">Model</a></li>
                                <li><a href="../classes/Mutable.html">Mutable</a></li>
                                <li><a href="../classes/Node.html">Node</a></li>
                                <li><a href="../classes/Perspective.html">Perspective</a></li>
                                <li><a href="../classes/perspective.html">perspective</a></li>
                                <li><a href="../classes/Point3.html">Point3</a></li>
                                <li><a href="../classes/PointLight.html">PointLight</a></li>
                                <li><a href="../classes/Renderer.html">Renderer</a></li>
                                <li><a href="../classes/RenderingContextUser.html">RenderingContextUser</a></li>
                                <li><a href="../classes/ShaderAttribLocation.html">ShaderAttribLocation</a></li>
                                <li><a href="../classes/ShaderAttribLocation..html">ShaderAttribLocation.</a></li>
                                <li><a href="../classes/ShaderProgram.html">ShaderProgram</a></li>
                                <li><a href="../classes/ShaderUniformLocation.html">ShaderUniformLocation</a></li>
                                <li><a href="../classes/ShaderVariableDecl.html">ShaderVariableDecl</a></li>
                                <li><a href="../classes/Spinor3.html">Spinor3</a></li>
                                <li><a href="../classes/Symbolic.html">Symbolic</a></li>
                                <li><a href="../classes/TreeModel.html">TreeModel</a></li>
                                <li><a href="../classes/UniformColor.html">UniformColor</a></li>
                                <li><a href="../classes/UniformDataInfo.html">UniformDataInfo</a></li>
                                <li><a href="../classes/UniformDataInfos.html">UniformDataInfos</a></li>
                                <li><a href="../classes/UniformFloat.html">UniformFloat</a></li>
                                <li><a href="../classes/UniformMetaInfo.html">UniformMetaInfo</a></li>
                                <li><a href="../classes/UniformMetaInfos.html">UniformMetaInfos</a></li>
                                <li><a href="../classes/UniformProvider.html">UniformProvider</a></li>
                                <li><a href="../classes/UniformSpinor3.html">UniformSpinor3</a></li>
                                <li><a href="../classes/UniformVariable.html">UniformVariable</a></li>
                                <li><a href="../classes/UniformVector3.html">UniformVector3</a></li>
                                <li><a href="../classes/Vector2.html">Vector2</a></li>
                                <li><a href="../classes/Vector3.html">Vector3</a></li>
                                <li><a href="../classes/view.html">view</a></li>
                                <li><a href="../classes/View.html">View</a></li>
                                <li><a href="../classes/WindowAnimationRunner.html">WindowAnimationRunner</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/EIGHT.html">EIGHT</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/modules/davinci-eight.d.ts</h1>

<div class="file">
    <pre class="code prettyprint linenums">
//
// davinci-eight.d.ts
//
// This file was created manually in order to support the davinci-eight library.
// These declarations are appropriate when using the library through the global
// variable, &#x27;EIGHT&#x27;.
//
declare module EIGHT
{
  /**
   * @class DrawMode
   */
  enum DrawMode {
    /**
     * POINTS
     */
    POINTS,
    LINES,
    TRIANGLES
  }
  enum DataUsage {
    STATIC_DRAW,
    DYNAMIC_DRAW,
    STREAM_DRAW
  }
  /**
   *
   */
  function initWebGL(canvas: HTMLCanvasElement, attributes?: WebGLContextAttributes): WebGLRenderingContext;

  /**
   *
   */
  interface ReferenceCounted {
    addRef(): void;
    release(): void;
  }

  /**
   *
   */
  interface RenderingContextUser extends ReferenceCounted {
    contextFree(): void;
    /**
     * Notification of a new WebGLRenderingContext.
     * @param context The WebGLRenderingContext.
     */
    contextGain(context: WebGLRenderingContext): void;
    /**
     * Notification that any WebGL resources cached are invalid because the WebGLContext has been lost.
     * This is a cue to rest to the initial state without attempting to dispose or free held resources.
     */
    contextLoss(): void;
    /**
     * Determines whether this context user has a valid WebGLRenderingContext.
     */
    hasContext(): boolean;
  }
  interface Drawable extends RenderingContextUser {
    /**
     *
     */
    program: ShaderProgram;
    /**
     *
     */
    draw(): void;
  }
  interface DrawList extends RenderingContextUser
  {
    /**
     * Add a drawable to the DrawList.
     */
    add(drawable: Drawable): void;
    /**
     * Removes a drawable from the DrawList.
     */
    remove(drawable: Drawable): void;
    /**
     * Sets the uniforms provided into all programs.
     */
    setUniforms(values: UniformDataInfos);
  }
  /**
   * Manages the lifecycle of an attribute used in a vertex shader.
   */
  class ShaderAttribLocation {
    constructor(name: string, glslType: string);
    contextFree(): void;
    contextGain(context: WebGLRenderingContext, program: WebGLProgram): void;
    contextLoss(): void;
    enable();
    disable();
    dataFormat(size: number, type?: number, normalized?: boolean, stride?: number, offset?: number);
    bufferData(data: AttribProvider);
  }
  interface ShaderUniformSetter {
    (data: UniformDataInfo): void
  }
  class ShaderUniformLocation {
    constructor(name: string, glslType: string);
    contextFree(): void;
    contextGain(context: WebGLRenderingContext, program: WebGLProgram): void;
    contextLoss(): void;
    createSetter(gl: WebGLRenderingContext, uniformInfo: WebGLActiveInfo): ShaderUniformSetter;
    uniform1f(x: number);
    uniform1fv(data: number[]);
    uniform2f(x: number, y: number);
    uniform2fv(data: number[]);
    uniform3f(x: number, y: number, z: number);
    uniform3fv(data: number[]);
    uniform4f(x: number, y: number, z: number, w: number);
    uniform4fv(data: number[]);
    uniformMatrix2fv(transpose: boolean, matrix: Float32Array);
    uniformMatrix3fv(transpose: boolean, matrix: Float32Array);
    uniformMatrix4fv(transpose: boolean, matrix: Float32Array);
  }
  /**
   *
   */
  class Mutable&lt;T&gt; {
    data: T;
    callback: () =&gt; T;
  }
  class Matrix3 {
    public elements: number[];
    constructor();
    identity(): void;
    normalFromMatrix4(matrix: Matrix4): void;
  }
  class Matrix4 {
    public elements: Float32Array;
    /**
     * Constructs a Matrix4 by wrapping an existing Float32Array.
     */
    constructor(elements: Float32Array);
    /**
     * Generates a new identity matrix.
     */
    static identity(): Matrix4;
    /**
     * Generates a new scaling matrix.
     */
    static scaling(scale: Cartesian3): Matrix4;
    /**
     * Generates a new translation matrix.
     */
    static translation(vector: Cartesian3): Matrix4;
    /**
     * Generates a new rotation matrix.
     */
    static rotation(spinor: Spinor3Coords): Matrix4;
    /**
     *
     */
    determinant(): number;
    /**
     *
     */
    identity(): Matrix4;
    invert(m: Matrix4, throwOnSingular?: boolean): Matrix4;
    mul(matrix: Matrix4): void;
    rotate(spinor: Spinor3Coords): void;
    rotation(spinor: Spinor3Coords): void;
    scale(scale: Cartesian3): void;
    scaling(scale: Cartesian3): void;
    translate(displacement: Cartesian3): void;
    translation(displacement: Cartesian3): void;
    frustum(left: number, right: number, bottom: number, top: number, near: number, far: number);
    toString(): string;
    toFixed(digits?: number): string;
  }
  interface Cartesian2 {
    x: number;
    y: number;
  }
  class Vector2 extends Mutable&lt;number[]&gt; implements Cartesian2 {
    public x: number;
    public y: number;
    constructor(vector?: number[]);
    add(v: Cartesian2): Vector2;
    addVectors(a: Cartesian2, b: Cartesian2): Vector2;
    copy(v: Cartesian2): Vector2;
    magnitude(): number;
    multiplyScalar(s: number): Vector2;
    quaditude(): number;
    set(x: number, y: number): Vector2;
    sub(v: Cartesian2): Vector2;
    subVectors(a: Cartesian2, b: Cartesian2): Vector2;
  }
  class Quaternion {
    public x: number;
    public y: number;
    public z: number;
    public w: number;
    public onChangeCallback: () =&gt; void;
    constructor(x?: number, y?: number, z?: number, w?: number);
    set(x: number, y: number, z: number, w: number);
    clone(): Quaternion;
    conjugate(): Quaternion;
    copy(quaternion: Quaternion): Quaternion;
    dot(v: Quaternion): number;
    inverse(): Quaternion;
    magnitude(): number;
    multiply(q: Quaternion): Quaternion;
    multiplyQuaternions(a: Quaternion, b: Quaternion): Quaternion;
    normalize(): Quaternion;
    onChange(callback: () =&gt; void): Quaternion;
    quaditude(): number;
    setFromAxisAngle(axis: Cartesian3, angle: number): Quaternion;
    setFromRotationMatrix(m: Matrix4): Quaternion;
    setFromUnitVectors(vFrom: Vector3, vTo: Vector3);
    slerp(qb: Quaternion, t: number): Quaternion;
    equals(quaternion: Quaternion);
    fromArray(array: number[], offset: number): Quaternion;
    toArray(array: number[], offset): number[];
    public static slerp(qa: Quaternion, qb: Quaternion, qm: Quaternion, t: number): Quaternion;
  }
  interface Spinor3Coords {
    yz: number;
    zx: number;
    xy: number;
    w: number;
  }
  class Spinor3 extends Mutable&lt;number[]&gt; implements Spinor3Coords {
    public yz: number;
    public zx: number;
    public xy: number;
    public w: number;
    public data: number[];
    public callback: () =&gt; number[];
    constructor(spinor?: number[]);
    clone(): Spinor3;
    copy(spinor: Spinor3Coords): Spinor3;
    toString(): string;
  }
  interface Cartesian3 {
    x: number;
    y: number;
    z: number;
  }
  class Vector3 extends Mutable&lt;number[]&gt; implements Cartesian3 {
    public x: number;
    public y: number;
    public z: number;
    public data: number[];
    public callback: () =&gt; number[];
    public static e1: Vector3;
    public static e2: Vector3;
    public static e3: Vector3;
    public static copy(vector: Cartesian3): Vector3;
    constructor(vector?: number[]);
    add(v: Cartesian3): Vector3;
    addVectors(a: Cartesian3, b: Cartesian3): Vector3;
    applyQuaternion(q: { x: number, y: number, z: number, w: number }): Vector3;
    clone(): Vector3;
    copy(v: Cartesian3): Vector3;
    cross(v: Cartesian3): Vector3;
    crossVectors(a: Cartesian3, b: Cartesian3): Vector3;
    distanceTo(position: Cartesian3): number;
    magnitude(): number;
    multiplyScalar(s: number): Vector3;
    normalize(): Vector3;
    quaditude(): number;
    quadranceTo(position: Cartesian3): number;
    set(x: number, y: number, z: number): Vector3;
    setMagnitude(magnitude: number): Vector3;
    sub(v: Cartesian3): Vector3;
    subVectors(a: Cartesian3, b: Cartesian3): Vector3;
  }
  /**
   *
   */
  interface UniformMetaInfo {
    /**
     * An optional override of the name that appears as the key in UniformMetaInfos.
     */
    name?: string;
    glslType: string;
  }
  interface UniformMetaInfos {
    [name: string]: UniformMetaInfo
  }
  interface UniformDataInfo {
    transpose?: boolean;
    x?: number;
    y?: number;
    z?: number;
    w?: number;
    vector?: number[];
    matrix2?: Float32Array;
    matrix3?: Float32Array;
    matrix4?: Float32Array;
    uniformZs?: Int32Array;
  }
  interface UniformDataInfos {
    [name: string]: UniformDataInfo
  }
  /**
   * Provides the runtime and design time data required to use a uniform in a vertex shader.
   */
  interface UniformProvider {
    getUniformFloat(name: string): number;
    getUniformMatrix3(name: string): { transpose: boolean; matrix3: Float32Array };
    getUniformMatrix4(name: string): { transpose: boolean; matrix4: Float32Array };
    getUniformVector2(name: string): number[];
    getUniformVector3(name: string): number[];
    getUniformVector4(name: string): number[];
    getUniformMeta(): UniformMetaInfos;
    getUniformData(): UniformDataInfos;
  }
  /**
   *
   */
  class AmbientLight implements UniformProvider {
    public color: UniformColor;
    constructor(options?: {color?: Color; name?: string});
    getUniformFloat(name: string): number;
    getUniformMatrix3(name: string): { transpose: boolean; matrix3: Float32Array };
    getUniformMatrix4(name: string): { transpose: boolean; matrix4: Float32Array };
    getUniformVector2(name: string): number[];
    getUniformVector3(name: string): number[];
    getUniformVector4(name: string): number[];
    getUniformMeta(): UniformMetaInfos;
    getUniformData(): UniformDataInfos;
  }
  /**
   *
   */
  class ChainedUniformProvider implements UniformProvider {
    constructor(one: UniformProvider, two: UniformProvider);
    getUniformFloat(name: string): number;
    getUniformMatrix3(name: string): { transpose: boolean; matrix3: Float32Array };
    getUniformMatrix4(name: string): { transpose: boolean; matrix4: Float32Array };
    getUniformVector2(name: string): number[];
    getUniformVector3(name: string): number[];
    getUniformVector4(name: string): number[];
    getUniformMeta(): UniformMetaInfos;
    getUniformData(): UniformDataInfos;
  }
  /**
   *
   */
  class DefaultAttribProvider implements AttribProvider {
    public drawMode: DrawMode;
    public dynamic: boolean;
    constructor();
    draw(): void;
    update(): void;
    getAttribArray(name: string): {usage: DataUsage; data: Float32Array};
    getAttribMeta(): AttribMetaInfos;
    hasElementArray(): boolean;
    getElementArray(): {usage: DataUsage; data: Uint16Array};
  }
  /**
   *
   */
  class DefaultUniformProvider implements UniformProvider {
    constructor();
    getUniformFloat(name: string);
    getUniformMatrix2(name: string): { transpose: boolean; matrix2: Float32Array };
    getUniformMatrix3(name: string): { transpose: boolean; matrix3: Float32Array };
    getUniformMatrix4(name: string): { transpose: boolean; matrix4: Float32Array };
    getUniformVector2(name: string): number[];
    getUniformVector3(name: string): number[];
    getUniformVector4(name: string): number[];
    getUniformMeta(): UniformMetaInfos;
    getUniformData(): UniformDataInfos;
  }
  /**
   *
   */
  class DirectionalLight implements UniformProvider {
    public color: UniformColor;
    public direction: UniformVector3;
    constructor(options?: {color?: Color; direction?: Cartesian3; name?: string});
    getUniformFloat(name: string): number;
    getUniformMatrix3(name: string): { transpose: boolean; matrix3: Float32Array };
    getUniformMatrix4(name: string): { transpose: boolean; matrix4: Float32Array };
    getUniformVector2(name: string): number[];
    getUniformVector3(name: string): number[];
    getUniformVector4(name: string): number[];
    getUniformMeta(): UniformMetaInfos;
    getUniformData(): UniformDataInfos;
  }
  /**
   *
   */
  class PointLight implements UniformProvider {
    public color: UniformColor;
    public position: UniformVector3;
    constructor(options?: {color?: Color; position?: Vector3; name?: string});
    getUniformFloat(name: string): number;
    getUniformMatrix3(name: string): { transpose: boolean; matrix3: Float32Array };
    getUniformMatrix4(name: string): { transpose: boolean; matrix4: Float32Array };
    getUniformVector2(name: string): number[];
    getUniformVector3(name: string): number[];
    getUniformVector4(name: string): number[];
    getUniformMeta(): UniformMetaInfos;
    getUniformData(): UniformDataInfos;
  }
  /**
   *
   */
  class MultiUniformProvider extends DefaultUniformProvider {
    constructor(providers: UniformProvider[]);
  }
  /**
   *
   */
  function uniforms(providers: UniformProvider[]): UniformProvider;
  /**
   *
   */
  interface UniformVariable&lt;T&gt; extends UniformProvider {
    data: T;
    callback: () =&gt; T;
  }
  /**
   * Represents a uniform vec3 for a Color.
   */
  class UniformColor extends DefaultUniformProvider implements UniformVariable&lt;Color&gt; {
    constructor(name: string, id?: string);
    data: Color;
    callback: () =&gt; Color;
  }
  /**
   * Represents a uniform vec3 for a Vector3.
   */
  class UniformVector3 extends DefaultUniformProvider implements UniformVariable&lt;Vector3&gt; {
    constructor(name: string, id?: string);
    data: Vector3;
    callback: () =&gt; Vector3;
  }
  /**
   * Represents a uniform vec4 for a Spinor3.
   */
  class UniformSpinor3 extends DefaultUniformProvider implements UniformVariable&lt;Spinor3&gt; {
    constructor(name: string, id?: string);
    data: Spinor3;
    callback: () =&gt; Spinor3;
  }
  /**
   * Represents a uniform float.
   */
  class UniformFloat extends DefaultUniformProvider implements UniformVariable&lt;number&gt; {
    constructor(name: string, id?: string);
    data: number;
    callback: () =&gt; number;
  }
  /**
   * Represents a uniform mat4.
   */
  class UniformMat4 extends DefaultUniformProvider implements UniformVariable&lt;{ transpose: boolean; matrix4: Float32Array}&gt; {
    constructor(name: string, id?: string);
    data: { transpose: boolean; matrix4: Float32Array};
    callback: () =&gt; { transpose: boolean; matrix4: Float32Array};
  }
  /**
   * Represents a uniform vec2.
   */
  class UniformVec2 extends DefaultUniformProvider implements UniformVariable&lt;number[]&gt; {
    constructor(name: string, id?: string);
    data: number[];
    callback: () =&gt; number[];
  }
  /**
   * Represents a uniform vec3.
   */
  class UniformVec3 extends DefaultUniformProvider implements UniformVariable&lt;number[]&gt; {
    constructor(name: string, id?: string);
    data: number[];
    callback: () =&gt; number[];
  }
  /**
   * Represents a uniform vec4.
   */
  class UniformVec4 extends DefaultUniformProvider implements UniformVariable&lt;number[]&gt; {
    constructor(name: string, id?: string);
    data: number[];
    callback: () =&gt; number[];
  }
  /**
   * Provides the uniform for the model to view coordinates transformation.
   */
  interface View extends UniformProvider {
    /**
     * The position of the view reference point, VRP.
     */
    eye: Vector3;
    /**
     * A special point in the world coordinates that defines the viewplane normal, VPN or n.
     * n = eye - look, normalized to unity.
     */
    look: Cartesian3;
    /**
     * A unit vector used to determine the view horizontal direction, u.
     * u = cross(up, n), and
     * v = cross(n, u).
     */
    up: Vector3;
    /**
     * Convenience method for setting the eye property allowing chainable method calls.
     */
    setEye(eye: Cartesian3): View;
    /**
     * Convenience method for setting the look property allowing chainable method calls.
     */
    setLook(look: Cartesian3): View;
    /**
     * Convenience method for setting the up property allowing chainable method calls.
     */
    setUp(up: Cartesian3): View;
  }
  interface Frustum extends View {
    left: number;
    right: number;
    bottom: number;
    top: number;
    near: number;
    far: number;
    /**
     * Convenience method for setting the eye property allowing chainable method calls.
     */
    setEye(eye: Cartesian3): Frustum;
    /**
     * Convenience method for setting the look property allowing chainable method calls.
     */
    setLook(look: Cartesian3): Frustum;
    /**
     * Convenience method for setting the up property allowing chainable method calls.
     */
    setUp(up: Cartesian3): Frustum;
  }
  /**
   * A transformation from the 3D world coordinates or view volume to the canonical view volume.
   * The canonical view volume is the cube that extends from -1 to +1
   * in all cartesian directions. 
   */
  interface Perspective extends View {
    /**
     * field of view angle in the view volume vertical plane, measured in radians.
     */
    fov: number;
    /**
     * ratio of width divided by height of the view volume.
     */
    aspect: number;
    /**
     * distance to the near plane of the view volume from the view reference point.
     */
    near: number;
    /**
     * distance to the far plane of the view volume from the view reference point.
     */
    far: number;
    /**
     * Convenience method for setting the fov property allowing chainable method calls.
     */
    setFov(fov: number): Perspective;
    /**
     * Convenience method for setting the aspect property allowing chainable method calls.
     */
    setAspect(aspect: number): Perspective;
    /**
     * Convenience method for setting the near property allowing chainable method calls.
     */
    setNear(near: number): Perspective;
    /**
     * Convenience method for setting the far property allowing chainable method calls.
     */
    setFar(far: number): Perspective;
    /**
     * Convenience method for setting the eye property allowing chainable method calls.
     */
    setEye(eye: Cartesian3): Perspective;
    /**
     * Convenience method for setting the look property allowing chainable method calls.
     */
    setLook(look: Cartesian3): Perspective;
    /**
     * Convenience method for setting the up property allowing chainable method calls.
     */
    setUp(up: Cartesian3): Perspective;
  }
  interface AttribMetaInfo {
    glslType: string,
    size: number,
    /**
     * An optional override of the name that appers as the key in AttributeMetaInfos.
     */
    name?: string,
    type?: number,
    normalized?: boolean,
    stride?: number,
    offset?: number
  }
  interface AttribMetaInfos {
    [name: string]: AttribMetaInfo;
  }
  /**
   * The generator of calls to drawArrays or drawElements and a source of attribute data.
   * This interface must be implemented in order to define a mesh.
   */
  interface AttribProvider extends RenderingContextUser
  {
    draw(): void;
    /**
     * Determines how the thing will be drawn.
     */
    drawMode: DrawMode;
    /**
     * Determines whether this Geometry changes. If so, update may be called repeatedly.
     */
    dynamic: boolean;
    /**
     * Declares the vertex shader attributes the geometry can supply and information required for binding.
     */
    getAttribMeta(): AttribMetaInfos;
    /**
     * Determines whether this Geometry uses WebGL&#x27;s drawElements() for rendering.
     */
    hasElementArray(): boolean;
    /**
     * Returns the elements used in an index buffer implementation.
     * An implementation of Geometry is not required to support index buffers and may return undefined.
     */
    getElementArray(): {usage: DataUsage; data: Uint16Array};
    /**
     * Returns the data when drawing using arrays. 
     */
    getAttribArray(name: string): {usage: DataUsage; data: Float32Array};
    /**
     * Notifies the mesh that it should update its array buffers.
     */
    update(): void;
  }
  class Face3 {
    public a: number;
    public b: number;
    public c: number;
    public normals: Vector3[];
    constructor(a: number, b: number, c: number, normals?: Vector3[]);
  }
  class Sphere {
    public center: Vector3;
    public radius: number;
    constructor(center?: Vector3, radius?: number);
    setFromPoints(points: Vector3[]);
  }
  /**
   * Base class for geometries.
   * A geometry holds all data necessary to describe a 3D model.
   */
  class Geometry {
    public vertices: Vector3[];
    public faces: Face3[];
    public faceVertexUvs: Vector2[][][];
    public dynamic: boolean;
    public verticesNeedUpdate: boolean;
    public elementsNeedUpdate: boolean;
    public uvsNeedUpdate: boolean;
    public boundingSphere: Sphere;
    constructor();
    //computeBoundingSphere(): void;
    computeFaceNormals(): void;
    computeVertexNormals(): void;
    mergeVertices(): void;
  }
  class Color
  {
    public red: number;
    public green: number;
    public blue: number;
    public data: number[];
    constructor(data?: number[]);
    public static fromHSL(H: number, S: number, L: number): Color;
    public static fromRGB(red: number, green: number, blue: number): Color;
  }
  class GeometryAdapter implements AttribProvider
  {
    drawMode: DrawMode;
    dynamic: boolean;
    constructor(geometry: Geometry, options?: {drawMode?: DrawMode});
    draw(): void;
    getAttribData(): AttribDataInfos;
    getAttribMeta(): AttribMetaInfos;
    hasElementArray(): boolean;
    getElementArray(): {usage: DataUsage; data: Uint16Array};
    getAttribArray(name: string): {usage: DataUsage; data: Float32Array};
    update(): void;
    addRef(): void;
    release(): void;
    contextFree(): void;
    contextGain(context: WebGLRenderingContext): void;
    contextLoss(): void;
    hasContext(): boolean;
  }
  class BarnGeometry extends Geometry {
    constructor();
  }
  class BoxGeometry extends Geometry {
    constructor(
      width: number,
      height: number,
      depth: number,
      widthSegments?:number,
      heightSegments?:number,
      depthSegments?:number);
  }
  class CylinderGeometry extends Geometry {
    constructor(
      radiusTop?: number,
      radiusBottom?: number,
      height?: number,
      radialSegments?: number,
      heightSegments?: number,
      openEnded?: boolean,
      thetaStart?: number,
      thetaLength?: number);
  }
  class EllipticalCylinderGeometry extends Geometry {
    constructor();
  }
  /**
   * A vertex shader and a fragment shader combined into a program.
   */
  interface ShaderProgram extends RenderingContextUser
  {
    program: WebGLProgram;
    programId: string;
    vertexShader: string;
    fragmentShader: string;
    /**
     * Makes the ShaderProgram the current program for WebGL.
     * This method has no effect if the ShaderProgram does not have a WebGLRenderingContext.
     */
    use(): void;
    /**
     * Sets the uniforms provided into the appropriate locations.
     */
    setUniforms(values: UniformDataInfos);
    /**
     *
     */
    attributeLocation(name: string): ShaderAttribLocation;
    /**
     *
     */
    uniformLocation(name: string): ShaderUniformLocation;
  }
  /**
   *
   */
  interface Composite&lt;M&gt; extends Drawable {
    model: M;
  }
  /**
   * The combination of a geometry, model and a program.
   */
  interface Primitive&lt;MESH extends AttribProvider, MODEL extends UniformProvider&gt; extends Composite&lt;MODEL&gt;
  {
    mesh: MESH;
  }
  interface Blade&lt;M&gt; extends Composite&lt;M&gt; {
    setMagnitude(magnitude: number): Blade&lt;M&gt;;
  }
  interface Renderer extends RenderingContextUser
  {
    /**
     * Defines whether the renderer should automatically clear its output before rendering.
     */
    autoClear: boolean;
    /**
     *
     */
    clearColor(red: number, green: number, blue: number, alpha: number);
    /**
     *
     */
    render(drawList: DrawList): void;
  }
  interface RendererParameters {
  }
  interface WindowAnimationRunner
  {
    start(): void;
    stop(): void;
    reset(): void;
    lap(): void;
    time: number;
    isRunning: boolean;
    isPaused: boolean;
  }
  interface Workbench3D
  {
    setUp(): void;
    tearDown(): void;
  }
  /**
   * Constructs and returns a DrawList.
   */
  function scene(): DrawList;
  function view(): View;
  /**
   * Constructs and returns a Perspective.
   */
  function frustum(
    left?: number,
    right?: number,
    bottom?: number,
    top?: number,
    near?: number,
    far?: number): Frustum;
  /**
   * Constructs and returns a symmetric perspective projection camera.
   */
  function perspective(
    options?: {
      fov?: number;
      aspect?: number;
      near?: number;
      far?: number;
      projectionMatrixName?: string;
      viewMatrixName?: string
    }): Perspective;
  /**
   * Constructs and returns a Renderer.
   * @param options Optional parameters for modifying the WebGL context.
   */
  function renderer(canvas: HTMLCanvasElement, options?: RendererParameters): Renderer;
  /**
   * Constructs a ShaderProgram from the specified vertex and fragment shader codes.
   */
  function shaderProgram(vertexShader: string, fragmentShader: string): ShaderProgram;
  /**
   * Constructs a ShaderProgram from the specified vertex and fragment shader script element identifiers.
   */
  function shaderProgramFromScripts(vsId: string, fsId: string, $document?: Document): ShaderProgram;
  /**
   * Constructs a ShaderProgram by introspecting a Geometry.
   */
  function smartProgram(attributes: AttribMetaInfos, uniformsList: UniformMetaInfos[]): ShaderProgram;
  /**
   * Constructs a Drawable from the specified attribute provider and program.
   * @param geometry
   * @param shaderProgram
   */
  function primitive&lt;MESH extends AttribProvider, MODEL extends UniformProvider&gt;(attributes: MESH, program: ShaderProgram, uniforms: MODEL): Primitive&lt;MESH, MODEL&gt;;
  /**
   *
   */
  class LocalModel extends DefaultUniformProvider {
    public position: Vector3;
    public attitude: Spinor3;
    public color: Color;
    constructor();
  }
  /**
   *
   */
  class TreeModel extends DefaultUniformProvider {
    constructor();
    setParent(parent: TreeModel);
  }
  /**
   *
   */
  class Node extends TreeModel {
    public position: Vector3;
    public attitude: Spinor3;
    public scale: Vector3;
    public color: Color;
    constructor(
      options?: {
        modelMatrixName?: string;
        normalMatrixName?: string;
        colorVarName?: string;
      });
  }
  /**
   *
   */
  class UniversalJoint extends TreeModel {
    public theta: number;
    public phi: number;
    constructor(options?: {modelMatrixVarName?: string});
  }
  /**
   *
   */
  interface ArrowOptions {
    axis?: Cartesian3;
    flavor?: number;
    coneHeight?: number;
    wireFrame?: boolean;
  }
  /**
   *
   */
  class ArrowBuilder {
    axis: Cartesian3;
    flavor: number;
    coneHeight: number;
    wireFrame: boolean;
    constructor(options?: ArrowOptions);
    setAxis(axis: Cartesian3): ArrowBuilder;
    setFlavor(flavor: number): ArrowBuilder;
    setConeHeight(coneHeight: number): ArrowBuilder;
    setWireFrame(wireFrame: boolean): ArrowBuilder;
    buildMesh(): AttribProvider;
  }
  /**
   * Constructs and returns an arrow mesh.
   */
  function arrowMesh(options?: ArrowOptions): AttribProvider;
  /**
   *
   */
  function arrow(ambients: UniformProvider, options?: ArrowOptions): Blade&lt;Node&gt;;
  /**
   *
   */
  interface BoxOptions {
    width?: number;
    height?: number;
    number?: number;
    widthSegments?: number;
    heightSegments?: number;
    numberSegments?: number;
    wireFrame?: boolean;
    positionVarName?: string;
    normalVarName?: string;
  }
  /**
   *
   */
  class BoxBuilder {
    width: number;
    height: number;
    number: number;
    widthSegments: number;
    heightSegments: number;
    numberSegments: number;
    wireFrame: boolean;
    positionVarName: string;
    constructor(options?: BoxOptions);
    setWidth(width: number): BoxBuilder;
    setHeight(height: number): BoxBuilder;
    setDepth(depth: number): BoxBuilder;
    setWidthSegments(widthSegments: number): BoxBuilder;
    setHeightSegments(heightSegments: number): BoxBuilder;
    setDepthSegments(depthSegments: number): BoxBuilder;
    setWireFrame(wireFrame: boolean): BoxBuilder;
    setPositionVarName(positionVarName: string): BoxBuilder;
    buildMesh(): AttribProvider;
  }
  /**
   * Constructs and returns a box mesh.
   */
  function boxMesh(options?: BoxOptions): AttribProvider;
  /**
   *
   */
  function box(ambients: UniformProvider, options: BoxOptions): Primitive&lt;AttribProvider, ShaderProgram, Node&gt;;
  /**
   *
   */
  interface CylinderOptions {
    radiusTop?: number;
    radiusBottom?: number;
    height?: number;
  }
  /**
   *
   */
  class CylinderArgs {
    radiusTop: number;
    radiusBottom: number;
    height: number;
    radialSegments: number;
    heightSegments: number;
    openEnded: boolean;
    wireFrame: boolean;
    constructor(options?: CylinderOptions);
    setRadiusTop(radiusTop: number): CylinderArgs;
    setRadiusBottom(radiusBottom: number): CylinderArgs;
    setHeight(height: number): CylinderArgs;
    setRadialSegments(radialSegments: number): CylinderArgs;
    setHeightSegments(heightSegments: number): CylinderArgs;
    setOpenEnded(openEnded: boolean): CylinderArgs;
    setThetaStart(thetaStart: number): CylinderArgs;
    setThetaLength(thetaLength: number): CylinderArgs;
    setWireFrame(wireFrame: boolean): CylinderArgs;
  }
  /**
   *
   */
  class CylinderMeshBuilder extends CylinderArgs {
    constructor(options?: CylinderOptions);
    setRadiusTop(radiusTop: number): CylinderMeshBuilder;
    setRadiusBottom(radiusBottom: number): CylinderMeshBuilder;
    setHeight(height: number): CylinderMeshBuilder;
    setRadialSegments(radialSegments: number): CylinderMeshBuilder;
    setHeightSegments(heightSegments: number): CylinderMeshBuilder;
    setOpenEnded(openEnded: boolean): CylinderMeshBuilder;
    setThetaStart(thetaStart: number): CylinderMeshBuilder;
    setThetaLength(thetaLength: number): CylinderMeshBuilder;
    setWireFrame(wireFrame: boolean): CylinderMeshBuilder;
    buildMesh(): AttribProvider;
  }
  /**
   * Constructs and returns a cylinder mesh.
   */
  function cylinderMesh(options?: CylinderOptions): AttribProvider;
  /**
   *
   */
  function cylinder(ambients: UniformProvider, options?: CylinderOptions): Primitive&lt;AttribProvider, ShaderProgram, LocalModel&gt;;
  /**
   *
   */
  interface SphereOptions {
    radius?: number;
    widthSegments?: number;
    heightSegments?: number;
    phiStart?: number;
    phiLength?: number;
    thetaStart?: number;
    thetaLength?: number;
    wireFrame?: boolean;
  }
  /**
   *
   */
  class SphereBuilder {
    radius: number;
    widthSegments: number;
    heightSegments: number;
    phiStart: number;
    phiLength: number;
    thetaStart: number;
    thetaLength: number;
    wireFrame: boolean;
    constructor(options?: SphereOptions);
    setRadius(radius: number): SphereBuilder;
    setWidthSegments(widthSegments: number): SphereBuilder;
    setHeightSegments(heightSegments: number): SphereBuilder;
    setPhiStart(phiStart: number): SphereBuilder;
    setPhiLength(phiLength: number): SphereBuilder;
    setThetaStart(phiStart: number): SphereBuilder;
    setThetaLength(phiLength: number): SphereBuilder;
    setWireFrame(wireFrame: boolean): SphereBuilder;
    buildMesh(): AttribProvider;
  }
  /**
   * Constructs and returns an vortex mesh.
   */
  function sphereMesh(options?: SphereOptions): AttribProvider;
  /**
   *
   */
  function sphere(ambients: UniformProvider, options?: SphereOptions): Primitive&lt;AttribProvider, ShaderProgram, LocalModel&gt;;
  /**
   * Constructs and returns an vortex mesh.
   */
  function vortexMesh(
    options?: {
      wireFrame?: boolean
    }
  ): AttribProvider;
  /**
   *
   */
  function vortex(
    ambients: UniformProvider
  ): Primitive&lt;AttribProvider, ShaderProgram, LocalModel&gt;;
  /**
   *
   */
  interface CuboidMesh extends AttribProvider {
    /**
     * The axis corresponding to e1.
     */
    a: Vector3;
    /**
     * The axis corresponding to e2.
     */
    b: Vector3;
    /**
     * The axis corresponding to e3.
     */
    c: Vector3;
    /**
     * The color of the cuboid.
     */
    color: Color;
    /**
     * The cuboid should be rendered using a gray scale.
     */
    grayScale: boolean;
  }
  /**
   * Constructs and returns a cuboid mesh.
   */
  function cuboid(spec?: {
    position?:{
      name?:string
    },
    color?:{
      name?:string,
      value?:Color
    }
    normal?:{
      name?:string
    }
  }): CuboidMesh;
  /**
   * A surface generated by the parametric equation:
   * a * cos(phi) * sin(theta) + b * cos(theta) + c * sin(phi) * sin(theta),
   * where phi and theta are the conventional spherical coordinates.
   */
  interface EllipsoidMesh extends AttribProvider {
    /**
     * The axis corresponding to (theta, phi) = (PI/2,0).
     */
    a: Vector3;
    /**
     * The axis corresponding to theta = 0.
     */
    b: Vector3;
    /**
     * The axis corresponding to (theta, phi) = (PI/2,PI/2).
     */
    c: Vector3;
    /**
     * The number of segments in the theta parameter.
     */
    thetaSegments: number;
    /**
     * The theta starting angle in radians.
     */
    thetaStart: number;
    /**
     * The theta sweep angle in radians.
     */
    thetaLength: number;
    /**
     * The number of segments in the phi parameter.
     */
    phiSegments: number;
    /**
     * The phi starting angle in radians.
     */
    phiStart: number;
    /**
     * The phi sweep angle in radians.
     */
    phiLength: number;
  }
  class ArrowGeometry extends Geometry {
    constructor();
  }
  class VortexGeometry extends Geometry {
    constructor();
  }
  class PolyhedronGeometry extends Geometry {
    constructor(vertices: number[], indices: number[], radius?:  number, detail?: number);
  }
  class DodecahedronGeometry extends PolyhedronGeometry {
    constructor(radius?: number, detail?: number);
  }
  class IcosahedronGeometry extends PolyhedronGeometry {
    constructor(radius?: number, detail?: number);
  }
  class KleinBottleGeometry extends ParametricSurfaceGeometry {
    constructor(uSegments: number, vSegments: number);
  }
  class MobiusStripGeometry extends ParametricSurfaceGeometry {
    constructor(uSegments: number, vSegments: number);
  }
  class OctahedronGeometry extends PolyhedronGeometry {
    constructor(radius?: number, detail?: number);
  }
  class ParametricSurfaceGeometry extends Geometry {
    constructor(parametricFunction: (u: number, v: number) =&gt; Cartesian3, uSegments: number, vSegments: number);
  }
  class SphereGeometry extends Geometry {
    constructor(
      radius?: number,
      widthSegments?: number,
      heightSegments?: number,
      phiStart?: number,
      phiLength?: number,
      thetaStart?: number,
      thetaLength?: number);
  }
  class TetrahedronGeometry extends PolyhedronGeometry {
    constructor(radius?: number, detail?: number);
  }
  class TubeGeometry extends Geometry {
    constructor(
      path: Curve,
      segments?: number,
      radius?: number,
      radialSegments?: number,
      closed?: boolean,
      taper?: (u: number)=&gt;number);
  }
  /**
   * Constructs and returns an ellipsoid mesh.
   */
  function ellipsoid(): EllipsoidMesh;
  /**
   * Constructs and returns a prism mesh.
   */
  function prism(): AttribProvider;
  /**
   *
   */
  class Curve {
    constructor();
  }
  /**
   * Constructs and returns a new Workbench3D.
   */
  function workbench(canvas: HTMLCanvasElement, viewport: Viewport, view: View, window: Window): Workbench3D;
  /**
   * Constructs and returns a WindowAnimationRunner.
   */
  function animation(
    animate: {(time: number): void;},
    options?: {
      setUp?: () =&gt; void;
      tearDown?: { (animateException): void; };
      terminate?: (time: number) =&gt; boolean;
      window?: Window}): WindowAnimationRunner;
  /**
   *
   */
  interface RenderingContextMonitor extends ReferenceCounted
  {
    /**
     * Starts the monitoring of the WebGL context.
     */
    start(): RenderingContextMonitor;
    /**
     * Stops the monitoring of the WebGL context.
     */
    stop(): RenderingContextMonitor;
    /**
     *
     */
    addContextUser(user: RenderingContextUser): RenderingContextMonitor;
    /**
     *
     */
    removeContextUser(user: RenderingContextUser): RenderingContextMonitor;
    /**
     *
     */
    context: WebGLRenderingContext;
  }
  /**
   * Constructs and returns a RenderingContextMonitor.
   */
  function contextMonitor(
    canvas: HTMLCanvasElement,
    attributes?: {
      alpha?: boolean,
      antialias?: boolean,
      depth?: boolean,
      premultipliedAlpha?: boolean,
      preserveDrawingBuffer?: boolean,
      stencil?: boolean
    }
    ): RenderingContextMonitor;
  /**
   * The version string of the davinci-eight module.
   */
  var VERSION: string;
}

declare module &#x27;EIGHT&#x27;
{
  export = EIGHT;
}

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
