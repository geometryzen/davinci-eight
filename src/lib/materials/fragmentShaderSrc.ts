import { mustBeBoolean } from "../checks/mustBeBoolean";
import { mustBeDefined } from "../checks/mustBeDefined";
import { config } from "../config";
import { AttribMetaInfo } from "../core/AttribMetaInfo";
import { getUniformVarName } from "../core/getUniformVarName";
import { GraphicsProgramSymbols as GPS } from "../core/GraphicsProgramSymbols";
import { UniformMetaInfo } from "../core/UniformMetaInfo";
import { GLSLESVersion } from "./glslVersion";

/**
 * @hidden
 */
function getUniformCodeName(uniforms: { [name: string]: UniformMetaInfo }, name: string) {
    return getUniformVarName(uniforms[name], name);
}

/**
 * @hidden
 */
function getFragColorVarName(version: GLSLESVersion) {
    if (version === GLSLESVersion.ThreeHundred) {
        return "fragColor";
    } else {
        return "gl_FragColor";
    }
}

/**
 * @hidden
 */
function getFragmentShaderVaryingModifier(version: GLSLESVersion) {
    if (version === GLSLESVersion.ThreeHundred) {
        return "in";
    } else {
        return "varying";
    }
}

/**
 * @hidden
 */
function getTexture2D(version: GLSLESVersion) {
    if (version === GLSLESVersion.ThreeHundred) {
        return "texture";
    } else {
        return "texture2D";
    }
}

/**
 * @hidden
 */
function emitFragmentFloatPrecision(version: GLSLESVersion): boolean {
    if (version === GLSLESVersion.ThreeHundred) {
        return true;
    } else {
        return false;
    }
}

/**
 * @hidden
 */
const SPACE = " ";
/**
 * @hidden
 */
const UNIFORM = "uniform" + SPACE;
/**
 * @hidden
 */
const SEMICOLON = ";";

/**
 * Generates a fragment shader
 * @hidden
 */
export function fragmentShaderSrc(attributes: { [name: string]: AttribMetaInfo }, uniforms: { [name: string]: UniformMetaInfo }, vColor: boolean, vCoords: boolean, vLight: boolean, version: GLSLESVersion) {
    mustBeDefined("attributes", attributes);
    mustBeDefined("uniforms", uniforms);
    mustBeBoolean(GPS.VARYING_COLOR, vColor);
    mustBeBoolean(GPS.VARYING_COORDS, vCoords);
    mustBeBoolean(GPS.VARYING_LIGHT, vLight);
    mustBeDefined("version", version);

    const lines: string[] = [];
    if (version === GLSLESVersion.ThreeHundred) {
        lines.push("#version 300 es");
    }
    lines.push(`// fragment shader generated by ${config.MARKETING_NAME}`);

    // Only the fragment shader requires an explicit precision for floats.
    // For fragment shaders, highp might not be available, which can be tested using the GL_FRAGMENT_PRECISION_HIGH macro.
    if (emitFragmentFloatPrecision(version)) {
        lines.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");
        lines.push("precision highp float;");
        lines.push("#else");
        lines.push("precision mediump float;");
        lines.push("#endif");
    }

    if (vColor) {
        lines.push(`${getFragmentShaderVaryingModifier(version)} highp vec4 ${GPS.VARYING_COLOR};`);
    }
    if (vCoords) {
        lines.push(`${getFragmentShaderVaryingModifier(version)} highp vec2 ${GPS.VARYING_COORDS};`);
    }
    if (vLight) {
        lines.push(`${getFragmentShaderVaryingModifier(version)} highp vec3 ${GPS.VARYING_LIGHT};`);
    }
    for (const uName in uniforms) {
        // eslint-disable-next-line no-prototype-builtins
        if (uniforms.hasOwnProperty(uName)) {
            switch (uniforms[uName].glslType) {
                case "sampler2D": {
                    lines.push(UNIFORM + uniforms[uName].glslType + SPACE + getUniformCodeName(uniforms, uName) + SEMICOLON);
                    break;
                }
                default: {
                    // Do nothing.
                }
            }
        }
    }

    // The color output variable must be declared explicitly.
    if (version === GLSLESVersion.ThreeHundred) {
        lines.push(`out vec4 ${getFragColorVarName(version)};`);
    }

    lines.push("void main(void) {");
    if (vLight) {
        if (vColor) {
            if (vCoords && uniforms[GPS.UNIFORM_IMAGE]) {
                lines.push(`  ${getFragColorVarName(version)} = ${getTexture2D(version)}(${GPS.UNIFORM_IMAGE}, ${GPS.VARYING_COORDS}) * vec4(${GPS.VARYING_COLOR}.xyz * ${GPS.VARYING_LIGHT}, ${GPS.VARYING_COLOR}.a);`);
            } else {
                lines.push(`  ${getFragColorVarName(version)} = vec4(${GPS.VARYING_COLOR}.xyz * ${GPS.VARYING_LIGHT}, ${GPS.VARYING_COLOR}.a);`);
            }
        } else {
            if (vCoords && uniforms[GPS.UNIFORM_IMAGE]) {
                lines.push(`  ${getFragColorVarName(version)} = ${getTexture2D(version)}(${GPS.UNIFORM_IMAGE}, ${GPS.VARYING_COORDS}) * vec4(${GPS.VARYING_LIGHT}, 1.0);`);
            } else {
                lines.push(`  ${getFragColorVarName(version)} = vec4(${GPS.VARYING_LIGHT}, 1.0);`);
            }
        }
    } else {
        if (vColor) {
            if (vCoords && uniforms[GPS.UNIFORM_IMAGE]) {
                lines.push(`  ${getFragColorVarName(version)} = ${getTexture2D(version)}(${GPS.UNIFORM_IMAGE}, ${GPS.VARYING_COORDS}) * ${GPS.VARYING_COLOR};`);
            } else {
                lines.push(`  ${getFragColorVarName(version)} = ${GPS.VARYING_COLOR};`);
            }
        } else {
            if (vCoords && uniforms[GPS.UNIFORM_IMAGE]) {
                lines.push(`  ${getFragColorVarName(version)} = ${getTexture2D(version)}(${GPS.UNIFORM_IMAGE}, ${GPS.VARYING_COORDS});`);
            } else {
                lines.push(`  ${getFragColorVarName(version)} = vec4(1.0, 1.0, 1.0, 1.0);`);
            }
        }
    }
    lines.push("}");
    lines.push("");
    const code = lines.join("\n");
    return code;
}
