import { AttribMetaInfo } from '../core/AttribMetaInfo';
import { config } from '../config';
import { getUniformVarName } from '../core/getUniformVarName';
import { GraphicsProgramSymbols as GPS } from '../core/GraphicsProgramSymbols';
import { mustBeBoolean } from '../checks/mustBeBoolean';
import { mustBeDefined } from '../checks/mustBeDefined';
import { UniformMetaInfo } from '../core/UniformMetaInfo';

const emitFragmentPrecision = false;
function getUniformCodeName(uniforms: { [name: string]: UniformMetaInfo }, name: string) {
  return getUniformVarName(uniforms[name], name);
}

const SPACE = ' ';
const UNIFORM = 'uniform' + SPACE;
const SEMICOLON = ';';

/**
 * Generates a fragment shader
 */
export function fragmentShaderSrc(attributes: { [name: string]: AttribMetaInfo }, uniforms: { [name: string]: UniformMetaInfo }, vColor: boolean, vCoords: boolean, vLight: boolean) {

  mustBeDefined('attributes', attributes);
  mustBeDefined('uniforms', uniforms);
  mustBeBoolean(GPS.VARYING_COLOR, vColor);
  mustBeBoolean(GPS.VARYING_COORDS, vCoords);
  mustBeBoolean(GPS.VARYING_LIGHT, vLight);

  const lines: string[] = [];
  lines.push(`// fragment shader generated by ${config.NAMESPACE} ${config.VERSION}`);
  // Only the fragment shader requires an explicit precision for floats.
  // For fragment shaders, highp might not be available, which can be tested using the GL_FRAGMENT_PRECISION_HIGH macro.
  // TODO: Make this an option.
  if (emitFragmentPrecision) {
    lines.push("#ifdef GL_ES");
    lines.push("#  ifdef GL_FRAGMENT_PRECISION_HIGH");
    lines.push("precision highp float;");
    lines.push("#  else");
    lines.push("precision mediump float;");
    lines.push("#  endif");
    lines.push("#endif");
  }
  if (vColor) {
    lines.push(`varying highp vec4 ${GPS.VARYING_COLOR};`);
  }
  if (vCoords) {
    lines.push(`varying highp vec2 ${GPS.VARYING_COORDS};`);
  }
  if (vLight) {
    lines.push(`varying highp vec3 ${GPS.VARYING_LIGHT};`);
  }
  for (let uName in uniforms) {
    if (uniforms.hasOwnProperty(uName)) {
      switch (uniforms[uName].glslType) {
        case 'sampler2D': {
          lines.push(UNIFORM + uniforms[uName].glslType + SPACE + getUniformCodeName(uniforms, uName) + SEMICOLON);
          break;
        }
        default: {
          // Do nothing.
        }
      }
    }
  }

  lines.push("void main(void) {");
  if (vLight) {
    if (vColor) {
      if (vCoords && uniforms[GPS.UNIFORM_IMAGE]) {
        lines.push(`  gl_FragColor = texture2D(${GPS.UNIFORM_IMAGE}, ${GPS.VARYING_COORDS}) * vec4(${GPS.VARYING_COLOR}.xyz * ${GPS.VARYING_LIGHT}, ${GPS.VARYING_COLOR}.a);`);
      }
      else {
        lines.push(`  gl_FragColor = vec4(${GPS.VARYING_COLOR}.xyz * ${GPS.VARYING_LIGHT}, ${GPS.VARYING_COLOR}.a);`);
      }
    }
    else {
      if (vCoords && uniforms[GPS.UNIFORM_IMAGE]) {
        lines.push(`  gl_FragColor = texture2D(${GPS.UNIFORM_IMAGE}, ${GPS.VARYING_COORDS}) * vec4(${GPS.VARYING_LIGHT}, 1.0);`);
      }
      else {
        lines.push(`  gl_FragColor = vec4(${GPS.VARYING_LIGHT}, 1.0);`);
      }
    }
  }
  else {
    if (vColor) {
      if (vCoords && uniforms[GPS.UNIFORM_IMAGE]) {
        lines.push(`  gl_FragColor = texture2D(${GPS.UNIFORM_IMAGE}, ${GPS.VARYING_COORDS}) * ${GPS.VARYING_COLOR};`);
      }
      else {
        lines.push(`  gl_FragColor = ${GPS.VARYING_COLOR};`);
      }
    }
    else {
      if (vCoords && uniforms[GPS.UNIFORM_IMAGE]) {
        lines.push(`  gl_FragColor = texture2D(${GPS.UNIFORM_IMAGE}, ${GPS.VARYING_COORDS});`);
      }
      else {
        lines.push("  gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);");
      }
    }
  }
  lines.push("}");
  lines.push("");
  const code = lines.join("\n");
  return code;
}
