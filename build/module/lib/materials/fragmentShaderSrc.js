import { config } from '../config';
import { getUniformVarName } from '../core/getUniformVarName';
import { GraphicsProgramSymbols as GPS } from '../core/GraphicsProgramSymbols';
import { mustBeBoolean } from '../checks/mustBeBoolean';
import { mustBeDefined } from '../checks/mustBeDefined';
var emitFragmentPrecision = false;
function getUniformCodeName(uniforms, name) {
    return getUniformVarName(uniforms[name], name);
}
var SPACE = ' ';
var UNIFORM = 'uniform' + SPACE;
var SEMICOLON = ';';
/**
 * Generates a fragment shader
 */
export function fragmentShaderSrc(attributes, uniforms, vColor, vCoords, vLight) {
    mustBeDefined('attributes', attributes);
    mustBeDefined('uniforms', uniforms);
    mustBeBoolean(GPS.VARYING_COLOR, vColor);
    mustBeBoolean(GPS.VARYING_COORDS, vCoords);
    mustBeBoolean(GPS.VARYING_LIGHT, vLight);
    var lines = [];
    lines.push("// fragment shader generated by " + config.NAMESPACE + " " + config.VERSION);
    // Only the fragment shader requires an explicit precision for floats.
    // For fragment shaders, highp might not be available, which can be tested using the GL_FRAGMENT_PRECISION_HIGH macro.
    // TODO: Make this an option.
    if (emitFragmentPrecision) {
        lines.push("#ifdef GL_ES");
        lines.push("#  ifdef GL_FRAGMENT_PRECISION_HIGH");
        lines.push("precision highp float;");
        lines.push("#  else");
        lines.push("precision mediump float;");
        lines.push("#  endif");
        lines.push("#endif");
    }
    if (vColor) {
        lines.push("varying highp vec4 " + GPS.VARYING_COLOR + ";");
    }
    if (vCoords) {
        lines.push("varying highp vec2 " + GPS.VARYING_COORDS + ";");
    }
    if (vLight) {
        lines.push("varying highp vec3 " + GPS.VARYING_LIGHT + ";");
    }
    for (var uName in uniforms) {
        if (uniforms.hasOwnProperty(uName)) {
            switch (uniforms[uName].glslType) {
                case 'sampler2D': {
                    lines.push(UNIFORM + uniforms[uName].glslType + SPACE + getUniformCodeName(uniforms, uName) + SEMICOLON);
                    break;
                }
                default: {
                    // Do nothing.
                }
            }
        }
    }
    lines.push("void main(void) {");
    if (vLight) {
        if (vColor) {
            if (vCoords && uniforms[GPS.UNIFORM_IMAGE]) {
                lines.push("  gl_FragColor = texture2D(" + GPS.UNIFORM_IMAGE + ", " + GPS.VARYING_COORDS + ") * vec4(" + GPS.VARYING_COLOR + ".xyz * " + GPS.VARYING_LIGHT + ", " + GPS.VARYING_COLOR + ".a);");
            }
            else {
                lines.push("  gl_FragColor = vec4(" + GPS.VARYING_COLOR + ".xyz * " + GPS.VARYING_LIGHT + ", " + GPS.VARYING_COLOR + ".a);");
            }
        }
        else {
            if (vCoords && uniforms[GPS.UNIFORM_IMAGE]) {
                lines.push("  gl_FragColor = texture2D(" + GPS.UNIFORM_IMAGE + ", " + GPS.VARYING_COORDS + ") * vec4(" + GPS.VARYING_LIGHT + ", 1.0);");
            }
            else {
                lines.push("  gl_FragColor = vec4(" + GPS.VARYING_LIGHT + ", 1.0);");
            }
        }
    }
    else {
        if (vColor) {
            if (vCoords && uniforms[GPS.UNIFORM_IMAGE]) {
                lines.push("  gl_FragColor = texture2D(" + GPS.UNIFORM_IMAGE + ", " + GPS.VARYING_COORDS + ") * " + GPS.VARYING_COLOR + ";");
            }
            else {
                lines.push("  gl_FragColor = " + GPS.VARYING_COLOR + ";");
            }
        }
        else {
            if (vCoords && uniforms[GPS.UNIFORM_IMAGE]) {
                lines.push("  gl_FragColor = texture2D(" + GPS.UNIFORM_IMAGE + ", " + GPS.VARYING_COORDS + ");");
            }
            else {
                lines.push("  gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);");
            }
        }
    }
    lines.push("}");
    lines.push("");
    var code = lines.join("\n");
    return code;
}
