import { mustBeBoolean } from '../checks/mustBeBoolean';
import { mustBeDefined } from '../checks/mustBeDefined';
import { config } from '../config';
import { getUniformVarName } from '../core/getUniformVarName';
import { GraphicsProgramSymbols as GPS } from '../core/GraphicsProgramSymbols';
import { GLSLESVersion } from './glslVersion';
/**
 * @hidden
 */
function getUniformCodeName(uniforms, name) {
    return getUniformVarName(uniforms[name], name);
}
/**
 * @hidden
 */
function getFragColorVarName(version) {
    if (version === GLSLESVersion.ThreeHundred) {
        return "fragColor";
    }
    else {
        return "gl_FragColor";
    }
}
/**
 * @hidden
 */
function getFragmentShaderVaryingModifier(version) {
    if (version === GLSLESVersion.ThreeHundred) {
        return "in";
    }
    else {
        return "varying";
    }
}
/**
 * @hidden
 */
function getTexture2D(version) {
    if (version === GLSLESVersion.ThreeHundred) {
        return "texture";
    }
    else {
        return "texture2D";
    }
}
/**
 * @hidden
 */
function emitFragmentFloatPrecision(version) {
    if (version === GLSLESVersion.ThreeHundred) {
        return true;
    }
    else {
        return false;
    }
}
/**
 * @hidden
 */
var SPACE = ' ';
/**
 * @hidden
 */
var UNIFORM = 'uniform' + SPACE;
/**
 * @hidden
 */
var SEMICOLON = ';';
/**
 * Generates a fragment shader
 * @hidden
 */
export function fragmentShaderSrc(attributes, uniforms, vColor, vCoords, vLight, version) {
    mustBeDefined('attributes', attributes);
    mustBeDefined('uniforms', uniforms);
    mustBeBoolean(GPS.VARYING_COLOR, vColor);
    mustBeBoolean(GPS.VARYING_COORDS, vCoords);
    mustBeBoolean(GPS.VARYING_LIGHT, vLight);
    mustBeDefined('version', version);
    var lines = [];
    if (version === GLSLESVersion.ThreeHundred) {
        lines.push("#version 300 es");
    }
    lines.push("// fragment shader generated by " + config.MARKETING_NAME + " " + config.VERSION);
    // Only the fragment shader requires an explicit precision for floats.
    // For fragment shaders, highp might not be available, which can be tested using the GL_FRAGMENT_PRECISION_HIGH macro.
    if (emitFragmentFloatPrecision(version)) {
        lines.push("#ifdef GL_FRAGMENT_PRECISION_HIGH");
        lines.push("precision highp float;");
        lines.push("#else");
        lines.push("precision mediump float;");
        lines.push("#endif");
    }
    if (vColor) {
        lines.push(getFragmentShaderVaryingModifier(version) + " highp vec4 " + GPS.VARYING_COLOR + ";");
    }
    if (vCoords) {
        lines.push(getFragmentShaderVaryingModifier(version) + " highp vec2 " + GPS.VARYING_COORDS + ";");
    }
    if (vLight) {
        lines.push(getFragmentShaderVaryingModifier(version) + " highp vec3 " + GPS.VARYING_LIGHT + ";");
    }
    for (var uName in uniforms) {
        if (uniforms.hasOwnProperty(uName)) {
            switch (uniforms[uName].glslType) {
                case 'sampler2D': {
                    lines.push(UNIFORM + uniforms[uName].glslType + SPACE + getUniformCodeName(uniforms, uName) + SEMICOLON);
                    break;
                }
                default: {
                    // Do nothing.
                }
            }
        }
    }
    // The color output variable must be declared explicitly.
    if (version === GLSLESVersion.ThreeHundred) {
        lines.push("out vec4 " + getFragColorVarName(version) + ";");
    }
    lines.push("void main(void) {");
    if (vLight) {
        if (vColor) {
            if (vCoords && uniforms[GPS.UNIFORM_IMAGE]) {
                lines.push("  " + getFragColorVarName(version) + " = " + getTexture2D(version) + "(" + GPS.UNIFORM_IMAGE + ", " + GPS.VARYING_COORDS + ") * vec4(" + GPS.VARYING_COLOR + ".xyz * " + GPS.VARYING_LIGHT + ", " + GPS.VARYING_COLOR + ".a);");
            }
            else {
                lines.push("  " + getFragColorVarName(version) + " = vec4(" + GPS.VARYING_COLOR + ".xyz * " + GPS.VARYING_LIGHT + ", " + GPS.VARYING_COLOR + ".a);");
            }
        }
        else {
            if (vCoords && uniforms[GPS.UNIFORM_IMAGE]) {
                lines.push("  " + getFragColorVarName(version) + " = " + getTexture2D(version) + "(" + GPS.UNIFORM_IMAGE + ", " + GPS.VARYING_COORDS + ") * vec4(" + GPS.VARYING_LIGHT + ", 1.0);");
            }
            else {
                lines.push("  " + getFragColorVarName(version) + " = vec4(" + GPS.VARYING_LIGHT + ", 1.0);");
            }
        }
    }
    else {
        if (vColor) {
            if (vCoords && uniforms[GPS.UNIFORM_IMAGE]) {
                lines.push("  " + getFragColorVarName(version) + " = " + getTexture2D(version) + "(" + GPS.UNIFORM_IMAGE + ", " + GPS.VARYING_COORDS + ") * " + GPS.VARYING_COLOR + ";");
            }
            else {
                lines.push("  " + getFragColorVarName(version) + " = " + GPS.VARYING_COLOR + ";");
            }
        }
        else {
            if (vCoords && uniforms[GPS.UNIFORM_IMAGE]) {
                lines.push("  " + getFragColorVarName(version) + " = " + getTexture2D(version) + "(" + GPS.UNIFORM_IMAGE + ", " + GPS.VARYING_COORDS + ");");
            }
            else {
                lines.push("  " + getFragColorVarName(version) + " = vec4(1.0, 1.0, 1.0, 1.0);");
            }
        }
    }
    lines.push("}");
    lines.push("");
    var code = lines.join("\n");
    return code;
}
