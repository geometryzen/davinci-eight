import { config } from '../config';
import { getAttribVarName } from '../core/getAttribVarName';
import { getUniformVarName } from '../core/getUniformVarName';
import { mustBeBoolean } from '../checks/mustBeBoolean';
import { mustBeDefined } from '../checks/mustBeDefined';
import { GraphicsProgramSymbols as GPS } from '../core/GraphicsProgramSymbols';
function getUniformCodeName(uniforms, name) {
    return getUniformVarName(uniforms[name], name);
}
var SPACE = ' ';
var ATTRIBUTE = 'attribute' + SPACE;
var UNIFORM = 'uniform' + SPACE;
var COMMA = ',' + SPACE;
var SEMICOLON = ';';
var LPAREN = '(';
var RPAREN = ')';
var TIMES = SPACE + '*' + SPACE;
var ASSIGN = SPACE + '=' + SPACE;
var DIRECTIONAL_LIGHT_COSINE_FACTOR_VARNAME = "directionalLightCosineFactor";
/**
 * Generates a vertex shader.
 */
export function vertexShaderSrc(attributes, uniforms, vColor, vCoords, vLight) {
    mustBeDefined('attributes', attributes);
    mustBeDefined('uniforms', uniforms);
    mustBeBoolean(GPS.VARYING_COLOR, vColor);
    mustBeBoolean(GPS.VARYING_COORDS, vCoords);
    mustBeBoolean(GPS.VARYING_LIGHT, vLight);
    var lines = [];
    lines.push("// vertex shader generated by " + config.NAMESPACE + " " + config.VERSION);
    // The precision is implicitly highp for vertex shaders.
    // So there is no need to add preamble for changing the precision unless
    // we want to lower the precision.
    for (var aName in attributes) {
        if (attributes.hasOwnProperty(aName)) {
            lines.push(ATTRIBUTE + attributes[aName].glslType + SPACE + getAttribVarName(attributes[aName], aName) + SEMICOLON);
        }
    }
    for (var uName in uniforms) {
        if (uniforms.hasOwnProperty(uName)) {
            switch (uniforms[uName].glslType) {
                case 'sampler2D': {
                    break;
                }
                default: {
                    lines.push(UNIFORM + uniforms[uName].glslType + SPACE + getUniformCodeName(uniforms, uName) + SEMICOLON);
                }
            }
        }
    }
    if (vColor) {
        lines.push("varying highp vec4 " + GPS.VARYING_COLOR + ";");
    }
    if (vCoords) {
        lines.push("varying highp vec2 " + GPS.VARYING_COORDS + ";");
    }
    if (vLight) {
        lines.push("varying highp vec3 " + GPS.VARYING_LIGHT + ";");
    }
    lines.push("void main(void) {");
    var glPosition = [];
    glPosition.unshift(SEMICOLON);
    if (attributes[GPS.ATTRIBUTE_POSITION]) {
        switch (attributes[GPS.ATTRIBUTE_POSITION].glslType) {
            case 'float': {
                // This case would be unusual; just providing an x-coordinate.
                // We must provide defaults for the y-, z-, and w-coordinates.
                glPosition.unshift(RPAREN);
                glPosition.unshift('1.0');
                glPosition.unshift(COMMA);
                glPosition.unshift('0.0');
                glPosition.unshift(COMMA);
                glPosition.unshift('0.0');
                glPosition.unshift(COMMA);
                glPosition.unshift(getAttribVarName(attributes[GPS.ATTRIBUTE_POSITION], GPS.ATTRIBUTE_POSITION));
                glPosition.unshift(LPAREN);
                glPosition.unshift('vec4');
                break;
            }
            case 'vec2': {
                // This case happens when the user wants to work in 2D.
                // We must provide a value for the homogeneous w-coordinate,
                // as well as the z-coordinate.
                glPosition.unshift(RPAREN);
                glPosition.unshift('1.0');
                glPosition.unshift(COMMA);
                glPosition.unshift('0.0');
                glPosition.unshift(COMMA);
                glPosition.unshift(getAttribVarName(attributes[GPS.ATTRIBUTE_POSITION], GPS.ATTRIBUTE_POSITION));
                glPosition.unshift(LPAREN);
                glPosition.unshift('vec4');
                break;
            }
            case 'vec3': {
                // This is probably the most common case, 3D but only x-, y-, z-coordinates.
                // We must provide a value for the homogeneous w-coordinate.
                glPosition.unshift(RPAREN);
                glPosition.unshift('1.0');
                glPosition.unshift(COMMA);
                glPosition.unshift(getAttribVarName(attributes[GPS.ATTRIBUTE_POSITION], GPS.ATTRIBUTE_POSITION));
                glPosition.unshift(LPAREN);
                glPosition.unshift('vec4');
                break;
            }
            case 'vec4': {
                // This happens when the use is working in homodeneous coordinates.
                // We don't need to use the constructor function at all.
                glPosition.unshift(getAttribVarName(attributes[GPS.ATTRIBUTE_POSITION], GPS.ATTRIBUTE_POSITION));
                break;
            }
        }
    }
    else {
        glPosition.unshift("vec4(0.0, 0.0, 0.0, 1.0)");
    }
    // Reflections are applied first.
    if (uniforms[GPS.UNIFORM_REFLECTION_ONE_MATRIX]) {
        glPosition.unshift(TIMES);
        glPosition.unshift(getUniformCodeName(uniforms, GPS.UNIFORM_REFLECTION_ONE_MATRIX));
    }
    if (uniforms[GPS.UNIFORM_REFLECTION_TWO_MATRIX]) {
        glPosition.unshift(TIMES);
        glPosition.unshift(getUniformCodeName(uniforms, GPS.UNIFORM_REFLECTION_TWO_MATRIX));
    }
    if (uniforms[GPS.UNIFORM_MODEL_MATRIX]) {
        glPosition.unshift(TIMES);
        glPosition.unshift(getUniformCodeName(uniforms, GPS.UNIFORM_MODEL_MATRIX));
    }
    if (uniforms[GPS.UNIFORM_VIEW_MATRIX]) {
        glPosition.unshift(TIMES);
        glPosition.unshift(getUniformCodeName(uniforms, GPS.UNIFORM_VIEW_MATRIX));
    }
    if (uniforms[GPS.UNIFORM_PROJECTION_MATRIX]) {
        glPosition.unshift(TIMES);
        glPosition.unshift(getUniformCodeName(uniforms, GPS.UNIFORM_PROJECTION_MATRIX));
    }
    glPosition.unshift(ASSIGN);
    glPosition.unshift("gl_Position");
    glPosition.unshift('  ');
    lines.push(glPosition.join(''));
    if (uniforms[GPS.UNIFORM_POINT_SIZE]) {
        lines.push("  gl_PointSize = " + getUniformCodeName(uniforms, GPS.UNIFORM_POINT_SIZE) + ";");
    }
    if (vColor) {
        if (attributes[GPS.ATTRIBUTE_COLOR]) {
            var colorAttribVarName = getAttribVarName(attributes[GPS.ATTRIBUTE_COLOR], GPS.ATTRIBUTE_COLOR);
            switch (attributes[GPS.ATTRIBUTE_COLOR].glslType) {
                case 'vec4': {
                    lines.push("  " + GPS.VARYING_COLOR + " = " + colorAttribVarName + SEMICOLON);
                    break;
                }
                case 'vec3': {
                    if (uniforms[GPS.UNIFORM_OPACITY]) {
                        lines.push("  " + GPS.VARYING_COLOR + " = vec4(" + colorAttribVarName + ", " + getUniformCodeName(uniforms, GPS.UNIFORM_OPACITY) + ");");
                    }
                    else {
                        lines.push("  " + GPS.VARYING_COLOR + " = vec4(" + colorAttribVarName + ", 1.0);");
                    }
                    break;
                }
                default: {
                    throw new Error("Unexpected type for color attribute: " + attributes[GPS.ATTRIBUTE_COLOR].glslType);
                }
            }
        }
        else if (uniforms[GPS.UNIFORM_COLOR]) {
            var colorUniformVarName = getUniformCodeName(uniforms, GPS.UNIFORM_COLOR);
            switch (uniforms[GPS.UNIFORM_COLOR].glslType) {
                case 'vec4': {
                    lines.push("  vColor = " + colorUniformVarName + SEMICOLON);
                    break;
                }
                case 'vec3': {
                    if (uniforms[GPS.UNIFORM_OPACITY]) {
                        lines.push("  " + GPS.VARYING_COLOR + " = vec4(" + colorUniformVarName + ", " + getUniformCodeName(uniforms, GPS.UNIFORM_OPACITY) + ");");
                    }
                    else {
                        lines.push("  " + GPS.VARYING_COLOR + " = vec4(" + colorUniformVarName + ", 1.0);");
                    }
                    break;
                }
                default: {
                    throw new Error("Unexpected type for color uniform: " + uniforms[GPS.UNIFORM_COLOR].glslType);
                }
            }
        }
        else {
            lines.push("  " + GPS.VARYING_COLOR + " = vec4(1.0, 1.0, 1.0, 1.0);");
        }
    }
    if (vCoords) {
        lines.push("  " + GPS.VARYING_COORDS + " = " + GPS.ATTRIBUTE_COORDS + ";");
    }
    if (vLight) {
        if (uniforms[GPS.UNIFORM_DIRECTIONAL_LIGHT_COLOR] && uniforms[GPS.UNIFORM_DIRECTIONAL_LIGHT_DIRECTION] && uniforms[GPS.UNIFORM_NORMAL_MATRIX] && attributes[GPS.ATTRIBUTE_NORMAL]) {
            lines.push("  vec3 L = normalize(" + getUniformCodeName(uniforms, GPS.UNIFORM_DIRECTIONAL_LIGHT_DIRECTION) + ");");
            lines.push("  vec3 N = normalize(" + getUniformCodeName(uniforms, GPS.UNIFORM_NORMAL_MATRIX) + " * " + getAttribVarName(attributes[GPS.ATTRIBUTE_NORMAL], GPS.ATTRIBUTE_NORMAL) + ");");
            lines.push("  // The minus sign arises because L is the light direction, so we need dot(N, -L) = -dot(N, L)");
            lines.push("  float " + DIRECTIONAL_LIGHT_COSINE_FACTOR_VARNAME + " = max(-dot(N, L), 0.0);");
            if (uniforms[GPS.UNIFORM_AMBIENT_LIGHT]) {
                lines.push("  " + GPS.VARYING_LIGHT + " = " + getUniformCodeName(uniforms, GPS.UNIFORM_AMBIENT_LIGHT) + " + " + DIRECTIONAL_LIGHT_COSINE_FACTOR_VARNAME + " * " + getUniformCodeName(uniforms, GPS.UNIFORM_DIRECTIONAL_LIGHT_COLOR) + ";");
            }
            else {
                lines.push("  " + GPS.VARYING_LIGHT + " = " + DIRECTIONAL_LIGHT_COSINE_FACTOR_VARNAME + " * " + getUniformCodeName(uniforms, GPS.UNIFORM_DIRECTIONAL_LIGHT_COLOR) + ";");
            }
        }
        else {
            if (uniforms[GPS.UNIFORM_AMBIENT_LIGHT]) {
                lines.push("  " + GPS.VARYING_LIGHT + " = " + getUniformCodeName(uniforms, GPS.UNIFORM_AMBIENT_LIGHT) + ";");
            }
            else {
                lines.push("  " + GPS.VARYING_LIGHT + " = vec3(1.0, 1.0, 1.0);");
            }
        }
    }
    lines.push("}");
    lines.push("");
    var code = lines.join("\n");
    return code;
}
